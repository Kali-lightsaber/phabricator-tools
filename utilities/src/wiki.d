/**
 * Copyright 2018
 * MIT License
 * Phabricator specific handling
 */
module matrixd.phabricator;
import common;
import phabricator.api;
import phabricator.common;
import phabricator.util.conv2wiki;
import phabricator.util.diffusion;
import phabricator.util.indexing;
import phabricator.util.wiki2dash;
import std.algorithm: canFind, sort;
import std.conv: to;
import std.json;
import std.string: format, join, split, startsWith, strip;

// generic page header
private enum GenPageHeader = "
> this page is generated by a bot
> **DO NOT** edit it here
\n";

/**
 * Generate primitive markdown columns/tables
 */
private static string generateColumns(string[] args)
{
    return format("| %s |", join(args, " | "));
}

/**
 * Update whois
 */
private static void updateWhoIs(API api)
{
    wikiFromSource(api, "whois", &fullWhoIs);
}

/**
 * Update contacts
 */
private static void upContacts(API api)
{
    wikiFromSource(api, "contacts", &doContacts);
}

/**
 * Full whois processing
 */
private static bool fullWhoIs(API api)
{
    auto result = wikiFromSource(api, WhoIsOpts, Conv.nameAlias);
    if (result)
    {
        try
        {
            auto settings = getSettings(api);
            auto opts = api.context[WhoIsOpts].split(",");
            auto raw = getDiffusion(settings, opts[2], opts[3], "master");
            auto lines = raw.split("\n");
            auto users = construct!UserAPI(settings).activeUsers();
            string[string] lookups;
            foreach (user; users[ResultKey][DataKey].array)
            {
                auto rawName = user[FieldsKey]["username"].str;
                auto userName = "@" ~ rawName;
                foreach (line; lines)
                {
                    if (line.startsWith(userName ~ ","))
                    {
                        auto parts = line.split(",");
                        foreach (part; parts[1..parts.length])
                        {
                            if (part != rawName && part.length > 0)
                            {
                                if (rawName !in lookups)
                                {
                                    lookups[rawName] = "";
                                }
                                else
                                {
                                    lookups[rawName] ~= ",";
                                }

                                lookups[rawName] ~= part;
                            }
                        }

                        break;
                    }
                }
            }

            auto obj = JSONValue(lookups);
            auto json = toJSON(obj);
            construct!PasteAPI(settings).editText(api.context[LookupsPHID], json);
        }
        catch (Exception e)
        {
            result = false;
        }
    }

    return result;
}

/**
 * Process contacts
 */
private static bool doContacts(API api)
{
    return wikiFromSource(api, ContactsOpts, Conv.catsub);
}

/**
 * Wiki generation from a source input
 */
private static void wikiFromSource(API api,
                                   string key,
                                   bool function(API) callback)
{
    if (!callback(api))
    {
        onError(key ~ " wiki update");
    }
}

/**
 * Generate a page from a source repo location
 */
private static bool wikiFromSource(API api, string key, Conv mode)
{
    auto settings = getSettings(api);
    auto opts = api.context[key].split(",");
    return wikiDiffusion(settings,
                         GenPageHeader,
                         opts[0],
                         opts[1],
                         opts[2],
                         opts[3],
                         "master",
                         mode);
}

/**
 * Generate a page
 */
private static void genPage(API api,
                            string contextKey,
                            string[] function(API, Settings) callback)
{
    auto parts = api.context[contextKey].split(",");
    auto slug = parts[0];
    auto title = parts[1];
    auto settings = getSettings(api);
    auto res = callback(api, settings);
    string[] objects;
    objects ~= res[0];
    objects ~= res[1];
    foreach (obj; res[2..res.length].sort!("a < b"))
    {
        objects ~= obj;
    }

    auto page = GenPageHeader ~ "---\n\n" ~ join(objects, "\n");
    auto phriction = construct!PhrictionAPI(settings);
    phriction.edit(slug, title, page);
}

/**
 * Build the index list
 */
private static string[] doIndexList(API api, Settings settings)
{
    string[] indexItems;
    indexItems ~= generateColumns(["index", "count"]);
    indexItems ~= generateColumns(["---", "---"]);
    auto vals = getIndexItems(settings);
    string[] tracked;
    string[] traced;
    foreach (item; vals.keys.sort!("a < b"))
    {
        auto tasks = vals[item].tasks;
        auto count = tasks.length;
        indexItems ~= generateColumns([item, to!string(count)]);
        foreach (phid; tasks)
        {
            traced ~= format("%s -> %s", item, phid);
        }

        auto clean = item.strip();
        if (tracked.canFind(clean))
        {
            onError("duplicate index found");
        }

        tracked ~= clean;
    }

    return indexItems;
}

/**
 * Do index processing
 */
private static void doIndex(API api)
{
    try
    {
        genPage(api, IndexOpts, &doIndexList);
    }
    catch (Exception e)
    {
        onError("unable to generate index page");
    }
}

/**
 * Convert wiki to dashboard
 */
private static void wikiToDash(API api)
{
    auto settings = getSettings(api);
    auto dashOpts = api.context[DashOpts].split(",");
    auto result =  convertToDashboard(settings,
                                      dashOpts[1],
                                      dashOpts[0]);
    if (!result)
    {
        onError("unable to update dashboard");
    }
}

/**
 * Entry point
 */
void main(string[] args)
{
    auto api = setup(args);
    updateWhoIs(api);
    upContacts(api);
    doIndex(api);
    wikiToDash(api);
    // NOTE: need to do api shutdown
}

