/**
 * Copyright 2017
 * MIT License
 * Phabricator specific handling
 */
module matrixd.phabricator;
import matrix.api;
import matrixd.common;
import phabricator.api;
import phabricator.common;
import phabricator.util.conv2wiki;
import phabricator.util.diffusion;
import phabricator.util.indexing;
import phabricator.util.projects;
import phabricator.util.tasks;
import phabricator.util.wiki2dash;
import std.algorithm: canFind, sort;
import std.ascii: isDigit, isPunctuation, isWhite;
import std.conv: to;
import std.datetime;
import std.getopt;
import std.json;
import std.random;
import std.string: endsWith, format, join, split, startsWith, strip, toLower;
import std.typecons;

// generic page header
private enum GenPageHeader = "
> this page is generated by a bot
> **DO NOT** edit it here
\n";

// phabricator api token
private enum PhabricatorToken = PhabIndicator ~ "TOKEN";

// dashboard (to update, wiki phid)
private enum DashOpts = PhabIndicator ~ "TO_DASH";

// Unmodified tasks (project, months, room)
private enum UnmodifiedOpts = PhabIndicator ~ "UNMODIFIED";

// index settings (slug, title)
private enum IndexOpts = PhabIndicator ~ "INDEX";

// contact settings (slug, title, path, callsign)
private enum ContactsOpts = PhabIndicator ~ "CONTACTS";

// whois settings (slug, title, path, callsign)
private enum WhoIsOpts = PhabIndicator ~ "WHOIS";

// Synapse lookup resolution (Paste PHID)
private enum LookupsPHID = "LOOKUP_PHID";

// User PHID
private enum PhabricatorUser = PhabIndicator ~ "USER_PHID";

// hidden tasks (paste phid, room)
private enum HiddenOpts = PhabIndicator ~ "HIDDEN";

/**
 * Get settings
 */
private static Settings getSettings(MatrixAPI api)
{
    auto settings = Settings();
    settings.url = api.context[PhabricatorURL];
    settings.token = api.context[PhabricatorToken];
    return settings;
}

/**
 * Get help text
 */
private static string getHelp(Option[] opts)
{
    string[] help;
    ulong shortest = 0;
    ulong longest = 0;
    foreach (it; opts)
    {
        if (it.optLong !is null && it.optLong.length > longest)
        {
            longest = it.optLong.length;
        }

        if (it.optShort !is null && it.optShort.length > shortest)
        {
            shortest = it.optShort.length;
        }
    }

    foreach (it; opts)
    {
        help ~= format("%*s %*s %s",
                       shortest + 1,
                       it.optShort,
                       longest + 1,
                       it.optLong,
                       it.help);
    }

    return format(PreSegmentHTML, join(help, "<br />"));
}

/**
 * Check opts, report if needed
 */
private static bool checkOpts(MatrixAPI api,
                              string roomId,
                              string[] segments,
                              GetoptResult opts)
{
    if (segments.length == 1 || opts.helpWanted)
    {
        api.sendHTML(roomId, getHelp(opts.options));
        return false;
    }
    else
    {
        return true;
    }
}

/**
 * Indicates this command is NOT a match
 */
private static bool noCommand(string bodyText, string cmd)
{
    return !isSingleCommand(bodyText, cmd) && !isCommand(bodyText, cmd);
}

/**
 * Parse the body, check the command, return the results
 * tuple (is valid?, raw, subselection)
 */
private static Tuple!(bool, string[], string[]) parseBody(JSONValue context,
                                                          string command)
{
    string bodyText = getBody(context);
    if (noCommand(bodyText, command))
    {
        return tuple(false, [""], [""]);
    }

    auto raw = bodyText.split(" ");
    return tuple(true, raw, raw[0..raw.length]);
}

/**
 * Generate primitive markdown columns/tables
 */
private static string generateColumns(string[] args)
{
    return format("| %s |", join(args, " | "));
}

/**
 * Manually generate wiki from source repo
 */
private static void wikiFromSource(MatrixAPI api,
                                   string roomId,
                                   JSONValue context,
                                   string key,
                                   bool function(MatrixAPI) callback)
{
    if (isSingleCommand(context, key))
    {
        string display = "failed";
        if (callback(api))
        {
            display = "completed";
        }

        api.sendText(roomId, key ~ " update " ~ display);
    }
}

/**
 * Update whois
 */
public static void updateWhoIs(MatrixAPI api, string roomId, JSONValue context)
{
    wikiFromSource(api, roomId, context, WhoIsValues, &doWhoIs);
}

/**
 * Update contacts
 */
public static void upContacts(MatrixAPI api, string roomId, JSONValue context)
{
    wikiFromSource(api, roomId, context, ContactValues, &doContacts);
}

/**
 * Update index stats
 */
public static void upIndex(MatrixAPI api, string roomId, JSONValue context)
{
    if (isSingleCommand(context, IndexValues))
    {
        doIndex(api);
        api.sendText(roomId, "index page updated");
    }
}

/**
 * Generate whois information
 */
public static bool doWhoIs(MatrixAPI api)
{
    return fullWhoIs(api, true);
}

/**
 * Partial whois processing
 */
private static bool partialWhoIs(MatrixAPI api)
{
    return fullWhoIs(api, false);
}

/**
 * Full whois processing
 */
private static bool fullWhoIs(MatrixAPI api, bool scheduled)
{
    auto result = wikiFromSource(api, WhoIsOpts, Conv.nameAlias);
    if (result)
    {
        try
        {
            auto settings = getSettings(api);
            auto opts = api.context[WhoIsOpts].split(",");
            auto raw = getDiffusion(settings, opts[2], opts[3], "master");
            auto lines = raw.split("\n");
            auto users = construct!UserAPI(settings).activeUsers();
            string[string] lookups;
            foreach (user; users[ResultKey][DataKey].array)
            {
                auto rawName = user[FieldsKey]["username"].str;
                auto userName = "@" ~ rawName;
                foreach (line; lines)
                {
                    if (line.startsWith(userName ~ ","))
                    {
                        auto parts = line.split(",");
                        foreach (part; parts[1..parts.length])
                        {
                            if (part != rawName && part.length > 0)
                            {
                                if (rawName !in lookups)
                                {
                                    lookups[rawName] = "";
                                }
                                else
                                {
                                    lookups[rawName] ~= ",";
                                }

                                lookups[rawName] ~= part;
                            }
                        }

                        break;
                    }
                }
            }

            if (scheduled)
            {
                auto obj = JSONValue(lookups);
                auto json = toJSON(obj);
                construct!PasteAPI(settings).editText(api.context[LookupsPHID],
                                                      json);
                requestUrl(api, "shutdown");
            }
        }
        catch (Exception e)
        {
            result = false;
        }
    }

    return result;
}

/**
 * Process contacts
 */
public static bool doContacts(MatrixAPI api)
{
    return wikiFromSource(api, ContactsOpts, Conv.catsub);
}

/**
 * Generate a page from a source repo location
 */
private static bool wikiFromSource(MatrixAPI api, string key, Conv mode)
{
    auto settings = getSettings(api);
    auto opts = api.context[key].split(",");
    return wikiDiffusion(settings,
                         GenPageHeader,
                         opts[0],
                         opts[1],
                         opts[2],
                         opts[3],
                         "master",
                         mode);
}

/**
 * Generate a page
 */
private static void genPage(MatrixAPI api,
                            string contextKey,
                            string[] function(MatrixAPI, Settings) callback)
{
    auto parts = api.context[contextKey].split(",");
    auto slug = parts[0];
    auto title = parts[1];
    auto settings = getSettings(api);
    auto res = callback(api, settings);
    string[] objects;
    objects ~= res[0];
    objects ~= res[1];
    foreach (obj; res[2..res.length].sort!("a < b"))
    {
        objects ~= obj;
    }

    auto page = GenPageHeader ~ "---\n\n" ~ join(objects, "\n");
    auto phriction = construct!PhrictionAPI(settings);
    phriction.edit(slug, title, page);
}

/**
 * Build the index list
 */
private static string[] doIndexList(MatrixAPI api, Settings settings)
{
    string[] indexItems;
    indexItems ~= generateColumns(["index", "count"]);
    indexItems ~= generateColumns(["---", "---"]);
    auto vals = getIndexItems(settings);
    string[] tracked;
    string[] traced;
    foreach (item; vals.keys.sort!("a < b"))
    {
        auto tasks = vals[item].tasks;
        auto count = tasks.length;
        indexItems ~= generateColumns([item, to!string(count)]);
        foreach (phid; tasks)
        {
            traced ~= format("%s -> %s", item, phid);
        }

        auto clean = item.strip();
        if (tracked.canFind(clean))
        {
            writeDump("duplicate index found", traced);
        }

        tracked ~= clean;
    }

    return indexItems;
}

/**
 * Link a task
 */
public static void linkTasks(MatrixAPI api, string roomId, JSONValue context)
{
    auto url = api.context[PhabricatorURL];
    auto tasks = findStarts("T", context);
    string[] tracked;
    foreach (tsk; tasks)
    {
        try
        {
            string t = "";
            if (tsk.length >= 2)
            {
                int positional = 0;
                bool outNumbered = false;
                bool invalidate = false;
                foreach (c; tsk)
                {
                    if (positional > 0)
                    {
                        if (isWhite(c))
                        {
                            break;
                        }

                        if (isPunctuation(c))
                        {
                            outNumbered = true;
                        }
                        else
                        {
                            bool checked = false;
                            if (!outNumbered)
                            {
                                if (isDigit(c))
                                {
                                    t ~= c;
                                    checked = true;
                                }
                            }

                            if (!checked)
                            {
                                invalidate = true;
                                break;
                            }
                        }
                    }

                    positional++;
                }

                if (invalidate)
                {
                    t = "";
                }
            }

            if (t.length > 0)
            {
                t = t.strip();
                auto i = to!int(t);
                t = "T" ~ t;
                if (!tracked.canFind(t)){
                    tracked ~= t;
                    auto task = format("<a href=\"%s%s\">%s</a>", url, t, t);
                    api.sendHTML(roomId,
                                 format(SegmentHTML, task));
                }
            }
        }
        catch (Exception e)
        {
            continue;
        }
    }
}

/**
 * Do index processing
 */
public static bool doIndex(MatrixAPI api)
{
    try
    {
        genPage(api, IndexOpts, &doIndexList);
        return true;
    }
    catch (Exception e)
    {
        return false;
    }
}

/**
 * Find hidden tasks
 */
public static void hiddenTasks(MatrixAPI api, string roomId, JSONValue context)
{
    auto parsed = parseBody(context, HiddenTasks);
    if (!parsed[0])
    {
        return;
    }

    int start;
    int page;
    auto opts = getopt(parsed[2],
                       "start",
                       "starting task number",
                       &start,
                       "page",
                       "paging range",
                       &page);
    if (checkOpts(api, roomId, parsed[1], opts))
    {
        hiddenTasks(api, roomId, start, page, true);
    }
}

/**
 * Hidden task checking
 */
private static int hiddenTasks(MatrixAPI api,
                               string roomId,
                               int start,
                               int page,
                               bool report)
{
    auto show = "none found";
    int last = -1;
    if (page < 1 || start < 1)
    {
        show = "please select a bounded start (> 0) and page (> 0)";
    }
    else
    {
        auto settings = getSettings(api);
        auto results = restricted(settings, start, page);
        if (results.length > 0)
        {
            show = "T" ~ join(results, ", T");
            foreach (result; results)
            {
                auto id = to!int(result);
                if (last == -1 || id < last)
                {
                    last = id;
                }
            }
        }
    }

    if (report)
    {
        api.sendText(roomId, show);
    }

    return last;
}

/**
 * Join projects
 */
public static bool doJoinProjects(MatrixAPI api)
{
    try
    {
        auto settings = getSettings(api);
        auto user = api.context[PhabricatorUser];
        auto proj = construct!ProjectAPI(settings);
        auto membership = proj.membersActive()[ResultKey][DataKey];
        string[] results;
        foreach (project; membership.array)
        {
            auto members = project["attachments"]["members"]["members"].array;
            auto matched = false;
            foreach (member; members)
            {
                auto phid = member["phid"].str;
                if (phid == user)
                {
                    matched = true;
                    break;
                }
            }

            if (!matched)
            {
                results ~= project[FieldsKey]["name"].str;
            }
        }

        if (results.length > 0)
        {
            api.sendText(api.context[DebugRoom],
                         "not a member of these projects:\n" ~
                         join(results, "\n"));
            return assignToActive(getSettings(api), user);
        }
        else
        {
            return true;
        }
    }
    catch (Exception e)
    {
        return false;
    }
}

/**
 * Scheduled hidden task checking
 */
public static bool doHiddenTasks(MatrixAPI api)
{
    try
    {
        auto lastStart = 1;
        auto opts = api.context[HiddenOpts].split(",");
        auto phid = opts[0];
        auto room = opts[1];
        auto settings = getSettings(api);
        auto paste = construct!PasteAPI(settings);
        auto contents = paste.activeByPHID(phid, true)[ResultKey][DataKey];
        auto attached = contents.array[0]["attachments"]["content"]["content"];
        auto text = attached.str.split("=");
        lastStart = to!int(text[1].strip());

        auto result = hiddenTasks(api, room, lastStart, 500, false);
        if (result != lastStart && result >= 0)
        {
            auto today = Clock.currTime().dayOfYear();
            paste.editText(phid, format("%s=%s", today, result));
        }
        else
        {
            api.sendText(room,
                         format("task visibility index unchanged: T%s",
                                result));
        }

        return true;
    }
    catch (Exception e)
    {
        return false;
    }
}

/**
 * Convert a wiki/phriction page to dashboard
 */
public static void wikiToDash(MatrixAPI api, string roomId, JSONValue context)
{
    if (!isSingleCommand(context, WikiToDash))
    {
        return;
    }

    auto displayText = "";
    if (wikiToDash(api))
    {
        displayText = "updated";
    }
    else
    {
        displayText = "failed";
    }

    api.sendText(roomId, displayText);
}

/**
 * Unmodified operations
 */
public static bool tasksUnmodified(MatrixAPI api)
{
    auto settings = getSettings(api);
    auto opts = api.context[UnmodifiedOpts].split(",");
    auto result = unmodified(settings, opts[0], to!int(opts[1]));
    return result;
}

/**
 * Convert wiki to dashboard
 */
public static bool wikiToDash(MatrixAPI api)
{
    auto settings = getSettings(api);
    auto dashOpts = api.context[DashOpts].split(",");
    return convertToDashboard(settings,
                              dashOpts[1],
                              dashOpts[0]);
}
